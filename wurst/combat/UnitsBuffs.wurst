package UnitsBuffs

// Standard imports
import ClosureTimers
import HashMap
import HashList
import LinkedList

// Custom imports
import public BuffType
import DilatableTime

constant real BUFFS_UPDATE_PERIOD = 0.1 //ANIMATION_PERIOD

constant real BUFF_ENDTIME_NEVER = 0.0

public constant real BUFF_DURATION_INFINITE = 0.0

public constant int BUFF_ID_STACKABLE = 0

/** Represents a currently active buff on a unit */
class UnitBuff
    private constant BuffType buffType
    private constant unit target
    private real beginTime = 0.0
    private real endTime = BUFF_ENDTIME_NEVER

    /** To put to true to remove the buff */
    private boolean stop = false

    construct(BuffType buffType, unit target, real duration)
        this.buffType = buffType
        this.target = target
        this.beginTime = TimeDilatation.getModifiedTime(this.target.getPos3Real())
        if duration != BUFF_DURATION_INFINITE
            this.endTime = this.beginTime + duration

    // Accessors
    function getBuffType() returns BuffType
        return this.buffType

    function isInfinite() returns boolean
        return this.endTime == BUFF_ENDTIME_NEVER

    function isFinished() returns boolean
        boolean finished = this.endTime != BUFF_ENDTIME_NEVER and TimeDilatation.getModifiedTime(target.getPos3Real()) >= this.endTime
        if finished and this.buffType == BUFF_TYPE_TEST
            Log.debug("A test buff is finished : begun at " + this.beginTime.toString() + " and ended at " + this.endTime.toString())
        return finished

/** Represents the list of buffs currently linked to a unit */
class UnitBuffs
    private constant unit who
    constant LinkedList<UnitBuff> buffs = new LinkedList<UnitBuff>()
    private constant HashList<int> buffsById = new HashList<int>()

    private constant BuffType sumBuff = new BuffType(0, "Computed virtual sum buff")

    construct(unit who)
        this.who = who

    function addBuff(BuffType buffType, real duration) returns boolean
        // Security test for debugging
        if buffType.id == BUFF_ID_STACKABLE and duration == BUFF_DURATION_INFINITE
            Log.error("Infinite duration buff with id 0 ! How is it supposed to be removed later ?! : " + buffType.name)

        // Is the buff stackable ?
        int id = buffType.id
        if id != BUFF_ID_STACKABLE
            // Non stackable buff : is it already present ?
            if this.buffsById.has(id)
                // Unit is already affected
                // FIXME -> Update existing buff(s) ??
            else
                // Non stackable buff
                this.buffs.add(new UnitBuff(buffType, this.who, duration))
                this.buffsById.add(id)
        else
            // The buff is stackable, just add it (do not list the ID which is 0)
            this.buffs.add(new UnitBuff(buffType, this.who, duration))

        // Is there a buff icon to show on the unit ?
        if buffType.abilityId != 0
            this.who.addAbility(buffType.abilityId)

        return true

    function hasBuffByType(BuffType buffType) returns boolean
        // Non-stackable buff ?
        if buffType.id != BUFF_ID_STACKABLE
            return this.buffsById.has(buffType.id)

        // Stackable buff
        let iter = this.buffs.iterator()
        while iter.hasNext()
            let unitBuffs = iter.next()
            if unitBuffs.getBuffType().id == buffType.id
                return true

        Log.debug("Unit has " + this.buffs.size().toString() + " buffs but not this one : " + buffType.name)
        
        return false

    function removeBuffByType(BuffType buffType) returns boolean
        // Is the buff stackable ?
        int id = buffType.id
        if id != BUFF_ID_STACKABLE
            // Non stackable buff : is it already present ?
            if this.buffsById.has(id)
                // Find the (only) buff and remove it
                this.buffsById.remove(id)
                let iter = this.buffs.iterator()
                while iter.hasNext()
                    let unitBuff = iter.next()
                    if unitBuff.getBuffType().id == id
                        destroy unitBuff
                        iter.remove()
                        break
            else
                // Buff not present : nothing to do
                return false
        else
            // The buff is stackable, remove all instances
            let iter = this.buffs.iterator()
            while iter.hasNext()
                let unitBuff = iter.next()
                if unitBuff.getBuffType().id == buffType.id
                    this.buffsById.remove(unitBuff.getBuffType().id)
                    iter.remove()
                    // FIXME maybe ajust return value ?

        // Is there a buff icon to hide ?
        if buffType.abilityId != 0
            this.who.removeAbility(buffType.abilityId)
        return true

    function update() returns boolean
        // Cleanup
        /*if this.sumBuff != null
            destroy this.sumBuff
        this.sumBuff = new BuffType(0, "Computed virtual sum buff")*/

        let iter = this.buffs.iterator()
        while iter.hasNext()
            let unitBuff = iter.next()
            if unitBuff.isFinished()
                iter.remove()

                Log.trace("Buff disappeared from " + this.who.getName() + " " + unitBuff.getBuffType().name)
                int id = unitBuff.getBuffType().id
                if id != BUFF_ID_STACKABLE
                    this.buffsById.remove(id)

                // Remove ability
                int abilityId = unitBuff.getBuffType().abilityId
                if abilityId != 0
                    this.who.removeAbility(abilityId)
                
                destroy unitBuff
        
        // Return true if this unit has no more buffs
        return this.buffs.size() == 0

    /*function destr()
        for UnitBuff unitBuff from this.buffs
            destroy unitBuff*/

    // Accessors
    function getSumBuff() returns BuffType
        return this.sumBuff

    function getUnit() returns unit
        return this.who

/** Class for handling all buffs of the game */
public class AllUnitsBuffs
    protected static constant HashMap<unit, UnitBuffs> MAP = new HashMap<unit, UnitBuffs>()
    protected static constant LinkedList<UnitBuffs> LIST = new LinkedList<UnitBuffs>()

    private static function getUnitBuffs(unit who) returns UnitBuffs
        UnitBuffs unitBuffs = MAP.get(who)
        if unitBuffs == null
            unitBuffs = new UnitBuffs(who)
            //Log.debug("Put " + who.getName())
            MAP.put(who, unitBuffs)
            LIST.add(unitBuffs)
        return unitBuffs

    static function addBuffPermanent(unit target, BuffType buffType)
        addBuffTimed(target, buffType, BUFF_DURATION_INFINITE)

    static function addBuffTimed(unit target, BuffType buffType, real duration)
        getUnitBuffs(target).addBuff(buffType, duration)

    static function removeBuffsByType(unit target, BuffType buffType)
        getUnitBuffs(target).removeBuffByType(buffType)

    static function hasBuffByType(unit target, BuffType buffType) returns boolean
        return getUnitBuffs(target).hasBuffByType(buffType)

    static function getTotalBuffs(unit target) returns BuffType
        return getUnitBuffs(target).getSumBuff()
    
    @deprecated("Bad idea to access the internal list... Try to avoid using this method as possible")
    private static function getAllBuffs(unit target) returns LinkedList<UnitBuff>
        return getUnitBuffs(target).buffs

// 
init
    Log.trace("Init units buffs")
    
    // Periodically update buffs
    doPeriodically(BUFFS_UPDATE_PERIOD) cb -> 
        let iter = AllUnitsBuffs.LIST.iterator()
        while iter.hasNext()
            UnitBuffs unitBuffs = iter.next()
            if unitBuffs.update()
                /*// Finished !
                iter.remove()
                AllUnitsBuffs.MAP.remove(unitBuffs.getUnit())
                destroy unitBuffs*/

    // When a unit dies -> Cleanup hashtable data
    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
        ..addAction() ->
            unit u = GetTriggerUnit()
            let unitBuffs = AllUnitsBuffs.MAP.get(u)
            if unitBuffs != null
                //unitBuffs.
