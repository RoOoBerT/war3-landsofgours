package Adventure

// Standard imports
import LinkedList
import HashMap

// Custom imports
import AdventureMarker
import AdventureCreaturePack
import CreaturePack
import Initialization
import PlayerData

/** Represents an adventure */
public abstract class Adventure
    private static int indexCounter = 0

    private constant int index
    private constant string name
    private constant string description
    private constant rect area

    /** List of available start locations */
    private constant LinkedList<AdventureStartLocation> startLocations = new LinkedList<AdventureStartLocation>

    /** List of creature packs */
    protected constant LinkedList<AdventureCreaturePack> creaturePacks = new LinkedList<AdventureCreaturePack>()
    protected constant HashMap<int, CreaturePack> creaturePacksMap = new HashMap<int, CreaturePack>()

    /** List of markers found on the area of the adventure */
    protected constant LinkedList<AdventureMarker> markers = new LinkedList<AdventureMarker>()

    construct(string name, string description, rect area)
        this.index = indexCounter
        indexCounter++

        this.name = name
        this.description = description
        this.area = area

    // Accessors
    function getIndex() returns int
        return this.index
    
    function getName() returns string
        return this.name

    function getDescription() returns string
        return this.description

    function getArea() returns rect
        return this.area
    
    // Modifiers
    function addStartLocation(AdventureStartLocation startLoc)
        this.startLocations.add(startLoc)
    
    function addMarker(AdventureMarker marker)
        this.markers.add(marker)
    
    function addCreaturePack(AdventureCreaturePack pack)
        this.creaturePacks.add(pack)

    // Functions
    function pickRandomStartLocation() returns AdventureStartLocation
        if this.startLocations.isEmpty()
            Log.error("Adventure #" + this.index.toString() + " has no start location !")
            return null

        int index = GetRandomInt(0, this.startLocations.size() - 1)
        return this.startLocations.get(index)

    // Abstract functions
    abstract function onStart() returns boolean

    abstract function onEnd() returns boolean

    /** Position every player's character */
    function setup() returns AdventureStartLocation
        // Position creatures
        for AdventureMarker marker in this.markers
            CreaturePack pack = this.creaturePacksMap.get(marker.getUnitTypeId())
            if pack != null
                pack.spawn(marker.getPosition(), marker.getOrientation())

        // Position players
        AdventureStartLocation startLocation = this.pickRandomStartLocation()
        vec2 position = startLocation.getPos()
        for player p in PlayerData.ACTIVE_PLAYERS
            let pd = PlayerData.get(p.getId())
            let character = pd.getCharacter()
            character.setPos(position)
            character.setFacing(startLocation.getOrientation())
            p.panCamToTimed(character, 0.0)
            p.selectSingle(character)

            position = position.polarOffset(startLocation.getOrientation(), 32.0)

        return startLocation

/** Represents a start location for players of an adventure */
public class AdventureStartLocation
    private constant vec2 pos
    private constant angle orientation

    construct (vec2 pos, angle orientation)
        this.pos = pos
        this.orientation = orientation
    
    function getPos() returns vec2
        return this.pos
    
    function getOrientation() returns angle
        return this.orientation

/** Manages the list of available adventures */
public class AdventureManager
    static constant LinkedList<Adventure> LIST = new LinkedList<Adventure>

    /** The currently ongoing adventure, or null if players are in town */
    private static Adventure currentAdventure = null

    /** Returns the currently ongoing adventure, or null if players are in town */
    static function getCurrent() returns Adventure
        return AdventureManager.currentAdventure

    /** Run the specified adventure. If null, gets back to town */
    static function run(Adventure adventure) returns boolean
        // Eventually stop/cleanup previous adventure
        Adventure previous = AdventureManager.getCurrent()
        if previous != null
            previous.onEnd()

        // Start the new adventure
        AdventureManager.currentAdventure = adventure
        if adventure != null
            adventure.onStart()

        return true

    /** Run a random adventure. */
    static function runRandom() returns boolean
        if AdventureManager.LIST.isEmpty()
            Log.error("No adventure registered !")
            return false
        
        int index = GetRandomInt(0, AdventureManager.LIST.size())
        Adventure adventure = AdventureManager.LIST.get(index)
        return run(adventure)

    /** Initialize an adventure's data for later use */
    static function initialize(Adventure adventure)
        Log.info("Adventure #" + adventure.getIndex().toString() + " : " + adventure.getName())

        // Filter
        UnitFilter filter = (unit u) -> u.getOwner() == PLAYER_GOURS_HOSTILE

        // Search for markers in the area
        group gp = CreateGroup()
        findUnitsMatching(gp, adventure.getArea(), filter, 0)
        for unit u in gp
            switch u.getTypeId()
                case 'n00B'
                    adventure.addStartLocation(new AdventureStartLocation(u.getPos(), u.getFacingAngle()))

                default
                    /*// Check if this is a marker of a known creatures pack
                    CreaturePack pack = adventure.creaturePacksMap.get(u.getTypeId())
                    if pack != null
                        adventure.addCreaturePack(new AdventureCreaturePack(u.getPos(), u.getFacingAngle(), pack))
                    else*/
                        // Store the unit's data into a generic marker
                        adventure.addMarker(new AdventureMarker(u))

            // Delete the unit
            u.remove()

        // Nettoyage memoire
        Log.debug("Adventure #" + adventure.getIndex().toString() + " - Nombre de marqueurs repertories : " + gp.size().toString())
        DestroyGroup(gp)

    /** Register the adventure */
    static function register(Adventure adventure)
        Log.info("Adventure #" + adventure.getIndex().toString() + " registered")
        LIST.addAt(adventure, adventure.getIndex())

// 
init
    //TODO register Players Ready
